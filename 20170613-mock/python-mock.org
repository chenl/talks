#+TITLE: Unit-testing in the real world with mock
#+AUTHOR: Chen Rotem Levy
#+EMAIL: chen@rotemlevy.name
#+DATE: [2017-06-13 Tue]
#+option: ^:nil
#+REVEAL_ROOT: http://cdn.jsdelivr.net/reveal.js/3.0.0/
#+REVEAL_EXTRA_CSS: ./custom.css

* Unit-testing in the real world with mock
#+CREDIT:    https://unsplash.com/photos/wOHH-NUTvVc (cc-0)
#+ATTR_HTML: :width 60% :height 60%
#+CAPTION:   Unit-testing in the real world with mock
#+NAME:      fig:TITLE
[[./img/dog_with_glasses.jpg]]
* chen@rotemlevy.name
#+ATTR_HTML: :width 50% :height 50%
#+CAPTION:   chen@rotemlevy.name
#+NAME:      fig:ABOUT_ME
[[./img/at_key_signing_party.jpg]]-
** Nerd
:PROPERTIES:
:reveal_background: ./img/at_key_signing_party.jpg
:reveal_background_trans: slide
:END:
- A nerd since 1968
- a computer geek since 1978
- GNU/* fan-boy since 1998
- Enjoying Python since [[https://www.python.org/download/releases/1.5/][v1.5.2]]
- Currently @ [[https://sentinelone.com/][SentinelOne]] found my job @ PyCon.il 2016 ([[https://sentinelone.com/jobs/][we are hiring]])
#+BEGIN_NOTES
My mother told me not to tire you too much, so I will do my best to be a good son.

(this slide is a POC for background image per slide)
#+END_NOTES
* Testing is important
#+CREDIT: https://unsplash.com/search/caution?photo=rNTXkBaQAvk (cc-0)
#+ATTR_HTML: :width 50% :height 50%
#+CATION: Testing is important
#+NAME:   fig:CAUTION
[[./img/caution.jpg]]
#+BEGIN_NOTES
Without it:
- You can't refactor
- Your productivity slows
- Your code crashes
- You loose all your hear
- And you will die!
#+END_NOTES

** Productivity
#+ATTR_HTML: :width 75% :height 75%
#+CAPTION: Productivity downward graph
#+NAME:    fig:DOWN_GRAPH
[[./img/down_graph.png]]

#+BEGIN_NOTES
I could show you a cheesy graph I made with [[https://inkscape.org/][INKSCAPE]]
#+END_NOTES

** Productivity

#+CREDIT: https://pixabay.com/en/animal-dog-unhappy-sad-art-2274100/, https://pixabay.com/en/china-dog-sad-animal-wet-1070771/
#+ATTR_HTML: :width 75% :height 75%
#+CAPTION: Sad wet dog
#+NAME:    fig:SAD_DOG
[[./img/sad_wet_dog.jpg]]

#+BEGIN_NOTES
But Instead I will show you a sad web doggy, which convey the same message.
You will be unhappy.
#+END_NOTES

** Doom

#+CREDIT: https://pixabay.com/p-2274100/ (cc-0)
#+ATTR_HTML: :width 75% :height 75%
#+CAPTION: A catastrophic software bug
#+NAME: fig:BOMB
[[./img/atomic_bomb.jpg]]

#+BEGIN_NOTES

If you listen to any of Uncle Bob Martin's talks you will here him say that some day soon lots of people are going to die due to a software bug, and it will be our fault.

And my mother asked me not to bore you too much, I imagine she will be upset if I will kill some of you...
#+END_NOTES

* So you want to learn you a unit-test

#+BEGIN_SRC python
def test_to_roman_numerals():
    assert to_roman_numerals(1949) == 'MCMXLIX'
    assert to_roman_numerals(2017) == 'MMXVII'
#+END_SRC

#+BEGIN_NOTES
When I tried to learn how to write unit-testing I mostly found tutorials that used example like this.

~to_roman_numerals(decial: int) -> str~ is a good boy:

It is a *pure* function. It gets a value and return a value that dependent *only* on its' input.
#+END_NOTES
** I will save the day

#+CREDIT:  https://unsplash.com/@zoncoll?photo=ZtLASJerPb0 (cc-0)
#+ATTR_HTML: :width 75% :height 75%
#+CAPTION: I will save the day
#+NAME:    fig:
[[./img/superman.jpg]]

#+BEGIN_NOTES
This is not too hard. I can do that.
Don't wary Humanity, I will save you!
#+END_NOTES

** Unit testing is hard

#+CREDIT:    https://unsplash.com/photos/-yz22gsqAH0 (cc-0)
#+ATTR_HTML: :width 50% :height 50%
#+CAPTION:   The real world is not as simple
#+NAME:      fig:KNOT
[[./img/kont.gpj]]

#+BEGIN_NOTES
- It inspects the world,
- Has side effects,
- calls external services (slow expensive, flaky)
- Might have random components

@TODO: consider a new slide for legacy code

- You have legacy code, with no code coverage, so you can't refactor,
  so you can't test so you don't have coverage...
#+END_NOTES

* Mocking

#+BEGIN_NOTES
Mocking is one way to isolate all the dependencies our unit requires, and replace them with an object that we will later be able to interrogate.

The dynamic nature of Python lends itself to for such manipulation by swapping the object our unit ask by name, and replace it with a Mock object.
#+END_NOTES

** Meet ~Mock~

#+CREDIT: https://unsplash.com/photos/BXs8SjVelKs
#+ATTR_HTML: :width 50% :height 50%
#+CAPTION: I am OK with that
#+NAME:    fig:MOCK
[[./img/happy_dog_with_a_hat.jpg]]

** Lets call this Mock Fido
Fido is an accommodating dude:
#+NAME: code:FIDO
#+BEGIN_SRC python
>>> fido = mock.Mock(name='Fido')
>>> fido
<Mock name='Fido' id='140518155448504'>
>>> fido()
<Mock name='Fido()' id='140518155482336'>
>>> fido.bark
<Mock name='Fido.bark' id='140518155483064'>
>>> fido.bark()
<Mock name='Fido.bark()' id='140518145633808'>
>>> fido.bark().run.after(42, what='cats')
<Mock name='Fido.bark().run.after()' id='140518145716856'>
#+END_SRC
** So what?
This is cool and all, but what is it sued for?
* Example: Guessing Game

#+CREDIT:    https://www.flickr.com/photos/thart2009/22658375526 (cc-by)
#+ATTR_HTML: :width 75% :height 75%
#+CAPTION:   The Enterprise Edition
#+NAME:      fig:ENTERPRISE
[[./img/enterprise.jpg]]

#+BEGIN_NOTES
This is the classic Guessing game, the computer picks a number than the player need to guess what it is, But with extra enterprise-ness.
#+END_NOTES
** play

#+BEGIN_SRC python
def play(level):
    # type: (int) -> None
    print(T("Level {level}: 0 to {max_num}").format(
        level=level, max_num=max_number(level)))
    num = think_of_a_number(level)
    while True:
        print(T("Can you guess what number I am thinking about?"))
        guess = your_guess()
        if guess is None:
            print(T("Just wanted you to know that I was thinking about {}").format(num))
            break
        if guess < num:
            print(T("No, my number is bigger than that"))
        elif guess > num:
            print(T("No, my number is smaller than that"))
        else:
            print(T("Yes, this is the number I was thinking about! "
                    "How did you konw that?"))
            break
#+END_SRC

#+BEGIN_NOTES
Sorry about the small font, but this is your run of the mill guessing game loop.

TODO: not sure if this needs to be here.
#+END_NOTES

** i18n.lang

#+BEGIN_SRC python
def lang():
    # type: () -> str
    lang_keys = ('LC_MESSAGES', 'LANG', 'LC_ALL')
    lang_env = (environ.get(key) for key in lang_keys)
    return next(filter(None, chain(lang_env, 'C')))[:2]
#+END_SRC

#+BEGIN_NOTES
One of G2E2 most Enterprise-y features is it ready-ness for the international market. So the first thing we need to do is to detect the player's language preference from the environment and report it.

Note that our legacy code was written in Python 2.7 but with and eye to Python 3 migration, according to PEP-484.

But this function doesn't get an input, instead it interrogates ~os.environ~, defaulting to ~"C"~ if no language found.

So how should we test this?

We could modify ~os.environ~, and see what we get, and it will work, but... `mock` gives us a better way to do that.
#+END_NOTES

** test_i18n.test_lang

#+BEGIN_SRC python
try:
    from unittest import mock  # Python >= 3.3
except ImportError:
    import mock                # Python < 3.3

def test_lang_default():
    with mock.patch.dict('guessing.i18n.environ', clear=True):
        assert i18n.lang() == 'C'
#+END_SRC

#+BEGIN_NOTES
There is a lot going on here:

First thing to note is while Python 3.3 comes with ~mock~ as part of the std-libs (under ~unittest~), in earlier we need to install it via ~pip~.

Next we use ~mock.patch.dict~ one of the patchers included in Python, here we use it as context manager.

There are several things we should note here:
- it will do the ~import~ for us.
- it modifies the binding of *names* and keeps the object as is.
- it restores the binding after it is done.
- since it change the binding the names we need to patch the names where they are used, not defined.
#+END_NOTES

** options
#+ATTR_HTML: :windth 50% :hiegnt 50%
#+CAPTION: About 1/2 of the unittest.mock standard documenation
#+NAME:    fig:DOCUMENATION
[[./img/documentaion.png]]

#+BEGIN_NOTES
Each patcher can take several options, all of them listed in the standard documentation.
BTW, I wanted to see if I can show all of the ~unittest.mock~ page in one slide, but I managed only about 1/2 of it.
#+END_NOTES

* Thoughts
** patch
   patches the *name* of something
** Mock makes it too easy

- it is too permissive (can be made better)
- if it is unit only, the boundaries between units aren't checked.
- [[https://medium.com/python-pandemonium/mock-or-not-to-mock-41965d33f175][to mock or not to mock]]

* One step on a long journey
  image: https://unsplash.com/photos/1JWmFju8vVg

- no tests
- with unit coverage
- define the boundaries you wish to mock
- define the way you want to construct your mock

* Credits
** links
  - [[https://www.youtube.com/watch?v=zW0f4ZRYF5M][Mocking Strategies]] ([[https://www.slideshare.net/excellaco/mocking-in-python-44973320][slides]]) / Excella's Dan Davis
    at the Django District Meetup group on Feb 10, 2015

  - [[https://www.youtube.com/watch?v=Xu5EhKVZdV8][Stop Moking, Start Testing]] / Augie Fackler, Nathaniel Manista
    Project Hosting at Google Code is a large, well-established system written mostly in Python. We'll share our battle-born convictions about creating tests for test-unfriendly code and the larger topic of testing.
** images
  title: https://unsplash.com/photos/wOHH-NUTvVc
  mock: https://unsplash.com/collections/262992/funny?photo=wOHH-NUTvVc
  happy dog with hat: https://unsplash.com/photos/BXs8SjVelKs
  duck typing: https://unsplash.com/?photo=5x7PmmHanG4
  flimsy: https://unsplash.com/?photo=5DJqsjAYlmk
  coverage: https://unsplash.com/?photo=2Ts5HnA67k8
  danger: https://unsplash.com/search/danger?photo=28v9cq7ytNU
  exception: https://unsplash.com/collections/440851/work?photo=EXuKQaf3Ei8
  brick wall: https://unsplash.com/?photo=daYpIvggFxA
  legacy code: https://unsplash.com/?photo=FX__egbD0zE
  atomic bomb: https://pixabay.com/en/atomic-bomb-mushroom-cloud-explosion-1011738/
  enterprise: https://www.flickr.com/photos/thart2009/22658375526
  sad dog: https://pixabay.com/en/animal-dog-unhappy-sad-art-2274100/
           https://pixabay.com/en/china-dog-sad-animal-wet-1070771/
* didn't make it
** Old examples
**** request time (inspect the world)

 #+BEGIN_SRC python
 from datetime import datetime
 import requests

 def request_time():
     r = requests.get('http://now.httpbin.org/')
     if r.status_code != 200:
        raise RuntimeError("Oy Vey!")
     return datetime.strptime(r.json()['now']['iso8601'],
                              '%Y-%m-%dT%H:%M:%S.%fZ')
 #+END_SRC

**** cmd2 (integration, mock os.system)

 #+BEGIN_SRC python
 >>> c = ExampleCmd()
 >>> c.one_cmd_plus_hooks('shell echo a')
 a
 #+END_SRC

 #+BEGIN_SRC python
 import os

 class ExampleCmd(cmd.Cmd):
     # ...
     def one_cmd_plus_hooks(self, line):
         # ...
         os.system(...)
 #+END_SRC

 #+BEGIN_SRC python
 from unittest.mock import patch

 @patch('os.system')
 def test_exmaple_cmd_shell(mock_system):
     c = ExampleCmd()
     c.one_cmd_plus_hooks('shell echo a')
     mock_system.assert_called_once_with('echo a')
 #+END_SRC

**** get json

 #+BEGIN_SRC python
 def get_json(filename):
     try:
         return json.loads(open(filename).read())
     except (IOError, ValueError):
         return {}
 #+END_SRC

 Well... I can create a `tempfile` with some json in it. And I can put some invalid json to have the ~ValueError~, and there must be something I can do to get an ~IOError~ and I will figure this out later somehow.

 But then you are writing a *functional* test.

**** credit card (side effect)

 #+BEGIN_SRC python
 def charge_credit_card(amount, cc_number, exp_month, exp_year):
     db = Database()
     q = OfflineQueue(db)
     ccp = CreditCardProcessor(q)
     c = CreditCard(cc_number, exp_month, exp_year)
     c.charge(ccp, amount)
 #+END_SRC
