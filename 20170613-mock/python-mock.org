#+TITLE: Unit-testing in the real world with mock
#+AUTHOR: Chen Rotem Levy
#+EMAIL: chen@rotemlevy.name
#+DATE: [2017-06-13 Tue]
#+OPTIONS: ^:nil num:nil toc:nil
#+REVEAL_ROOT: http://cdn.jsdelivr.net/reveal.js/3.0.0/
#+REVEAL_EXTRA_CSS: ./custom.css

* chen@rotemlevy.name
#+ATTR_HTML: :width 65% :height 65%
#+CAPTION:   Nerd!
#+NAME:      fig_ABOUT_ME
[[./img/at_key_signing_party.jpg]]

#+BEGIN_NOTES
- A nerd since 1968
- a computer geek since 1978
- GNU/* fan-boy since 1998
- Enjoying Python since [[https://www.python.org/download/releases/1.5/][v1.5.2]]
- Currently @ [[https://sentinelone.com/][SentinelOne]] found my job @ PyCon.il 2016 ([[https://sentinelone.com/jobs/][we are hiring]])

My mother told me not to tire you too much, so I will do my best to be a good son.
#+END_NOTES
* Testing is important
#+CREDIT:    https://unsplash.com/search/caution?photo=rNTXkBaQAvk (cc-0)
#+ATTR_HTML: :width 75% :height 75%
#+CAPTION:   Testing is important
#+NAME:      fig_CAUTION
[[./img/caution.jpg]]

#+BEGIN_NOTES
Without it:
- You can't refactor
- Your productivity slows
- Your code crashes
- You loose all your hear
- And you will die!
#+END_NOTES

** Productivity
#+ATTR_HTML: :width 75% :height 75%
#+CAPTION: Productivity suffers
#+NAME:    fig_DOWN_GRAPH
[[./img/down_graph.png]]

#+BEGIN_NOTES
I could show you a cheesy graph I made with [[https://inkscape.org/][INKSCAPE]]
#+END_NOTES

** Productivity

#+CREDIT: https://pixabay.com/en/animal-dog-unhappy-sad-art-2274100/, https://pixabay.com/en/china-dog-sad-animal-wet-1070771/
#+ATTR_HTML: :width 75% :height 75%
#+CAPTION: No tests
#+NAME:    fig_SAD_DOG
[[./img/sad_wet_dog.jpg]]

#+BEGIN_NOTES
But Instead I will show you a sad web doggy, which convey the same message.
You will be unhappy.
#+END_NOTES

** Doom

#+CREDIT: https://pixabay.com/p-2274100/ (cc-0)
#+ATTR_HTML: :width 85% :height 85%
#+CAPTION: A catastrophic software bug
#+NAME: fig_BOMB
[[./img/atomic_bomb.jpg]]

#+BEGIN_NOTES

If you listen to any of Uncle Bob Martin's talks you will here him say that some day soon lots of people are going to die due to a software bug, and it will be our fault.

And my mother asked me not to bore you too much, I imagine she will be upset if I will kill some of you...
#+END_NOTES

* So you want to learn you a unit-test

#+NAME: code_ROAMN
#+BEGIN_SRC python
def test_to_roman_numerals():
    assert to_roman_numerals(1949) == 'MCMXLIX'
    assert to_roman_numerals(2017) == 'MMXVII'
#+END_SRC

#+BEGIN_NOTES
When I tried to learn how to write unit-testing I mostly found tutorials that used example like this.

~to_roman_numerals(decial: int) -> str~ is a good boy:

It is a *pure* function. It gets a value and return a value that dependent *only* on its' input.
#+END_NOTES
** I will save the day

#+CREDIT:  https://unsplash.com/@zoncoll?photo=ZtLASJerPb0 (cc-0)
#+ATTR_HTML: :width 75% :height 75%
#+CAPTION: I will save the day
#+NAME:    fig_SUPERMAN
[[./img/superman.jpg]]

#+BEGIN_NOTES
This is not too hard. I can do that.
Don't wary Humanity, I will save you!
#+END_NOTES

** Unit testing is hard

#+CREDIT:    https://unsplash.com/photos/-yz22gsqAH0 (cc-0)
#+ATTR_HTML: :width 75% :height 75%
#+CAPTION:   The real world is not as simple
#+NAME:      fig_KNOT
[[./img/knot.jpg]]

#+BEGIN_NOTES
- It inspects the world,
- Has side effects,
- calls external services (slow expensive, flaky)
- Might have random components

@TODO: consider a new slide for legacy code

- You have legacy code, with no code coverage, so you can't refactor,
  so you can't test so you don't have coverage...
#+END_NOTES

* Example: Guessing Game

#+CREDIT:    https://www.flickr.com/photos/thart2009/22658375526 (cc-by)
#+ATTR_HTML: :width 85% :height 85%
#+CAPTION:   The Enterprise Edition
#+NAME:      fig_ENTERPRISE
[[./img/enterprise.jpg]]

#+BEGIN_NOTES
This is the classic Guessing game, the computer picks a number than the player need to guess what it is, But with extra enterprise-ness.
#+END_NOTES
** play

#+NAME: code_PLAY
#+BEGIN_SRC python
def play(level):
    # type: (int) -> None
    print(T("Level {level}: 0 to {max_num}").format(
        level=level, max_num=max_number(level)))
    num = think_of_a_number(level)
    while True:
        print(T("Can you guess what number I am thinking about?"))
        guess = your_guess()
        if guess is None:
            print(T("Just wanted you to know that "
                    "I was thinking about {}").format(num))
            break
        if guess < num:
            print(T("No, my number is bigger than that"))
        elif guess > num:
            print(T("No, my number is smaller than that"))
        else:
            print(T("Yes, this is the number I was thinking about! "
                    "How did you konw that?"))
            break
#+END_SRC

#+BEGIN_NOTES
Sorry about the small font, but this is your run of the mill guessing game loop.
It has a random component, it calls ~T~ (whatever that is), and it doesn't return anything. How can we test that?
#+END_NOTES

** One step back

#+ATTR_HTML: :width 50% :height 50%
#+CAPTION: (some of) the GGEE design
#+NAME:    fig_CALL_GRAPH_RICH
[[./img/call_graph_rich.png]]

#+BEGIN_NOTES
We see that game calls play, which ask for the player's guess.
The player might indicate that she want to quit the game, but this is dependent on the system's language which checks ~os.environ~
#+END_NOTES

** Low hanging

#+BEGIN_SRC python
def max_number(level):
    # type: (int) -> int
    return (1 << level) - 1

def test_max_number():
    assert game.max_number(1) == 1
    assert game.max_number(2) == 3
    assert game.max_number(3) == 7
#+END_SRC

#+END_SRC
* Mocking
#+CREDIT:    https://unsplash.com/photos/wOHH-NUTvVc (cc-0)
#+ATTR_HTML: :width 75% :height 75%
#+NAME:      fig_MOKING
[[./img/dog_with_glasses.jpg]]

#+BEGIN_NOTES
Mocking is one way to isolate all the dependencies our unit requires, and replace them with an object that we will later be able to interrogate.

The dynamic nature of Python lends itself to for such manipulation by swapping the object our unit ask by name, and replace it with a Mock object.
#+END_NOTES
** i18n.lang

#+NAME: code_LANG
#+BEGIN_SRC python
def lang():
    # type: () -> str
    lang_keys = ('LC_MESSAGES', 'LANG', 'LC_ALL')
    lang_env = (environ.get(key) for key in lang_keys)
    return next(filter(None, chain(lang_env, 'C')))[:2]
#+END_SRC

#+BEGIN_NOTES
One of G2E2 most Enterprise-y features is it ready-ness for the international market. So the first thing we need to do is to detect the player's language preference from the environment and report it.

Note that our legacy code was written in Python 2.7 but with and eye to Python 3 migration, according to PEP-484.

But this function doesn't get an input, instead it interrogates ~os.environ~, defaulting to ~"C"~ if no language found.

So how should we test this?

We could modify ~os.environ~, and see what we get, and it will work, but... `mock` gives us a better way to do that.
#+END_NOTES

** test_i18n.test_lang

#+BEGIN_SRC python
try:
    from unittest import mock
except ImportError:
    import mock  # Python < 3.3

@mock.patch.dict('guessing.i18n.environ',
                 LC_MESSAGES='he_IL')
def test_lang_lc_message_he():
    assert i18n.lang == 'he'
#+END_SRC

#+BEGIN_NOTES
There is a lot going on here:

First thing to note is while Python 3.3 comes with ~mock~ as part of the std-libs (under ~unittest~), in earlier we need to install it via ~pip~.

Next we use ~mock.patch.dict~ one of the patchers included in Python, here we use it as context manager.

There are several things we should note here:
- it will do the ~import~ for us.
- it modifies the binding of *names* and keeps the object as is.
- it restores the binding after it is done.
- since it change the binding the names we need to patch the names where they are used, not defined.
#+END_NOTES

** context manager

#+BEGIN_SRC python
def test_lang_default():
    with mock.patch.dict('guessing.i18n.environ',
                         clear=True):
        assert os.envrion == {}
        assert i18n.lang() == 'C'
#+END_SRC

#+BEGIN_NOTES
Next we want to test that if there are not values in `os.envrion` we get the our expected default language. We use ~clear=True~. We use here a context manager, just because.
#+END_NOTES

** options
#+ATTR_HTML: :windth 50% :hiegnt 50%
#+CAPTION:   About 1/2 of the unittest.mock standard documentation
#+NAME:      fig_DOCUMENATION
[[./img/documentation.png]]

#+BEGIN_NOTES
The mock API is very flexible, and all its' options are are listed in the standard documentation which is extensive.  I wanted to see if I can show all of the ~unittest.mock~ page in one slide, but I managed only about 1/2 of it.
#+END_NOTES

** what to mock
#+BEGIN_SRC python
def is_quit(text):
    # type: (str) -> bool
    if lang() == 'he':
        return text.strip() in [
            'לא', 'די', 'מספיק', 'צא בחוץ']
    else:
        return text.strip().lower() in [
            'quit', 'stop', 'exit', 'no', 'enough']
#+END_SRC

#+BEGIN_NOTES
When the game prompts the player to give a guess, she can instead can ask to quit the game.  But this is dependent of the player's language.

Again we *could* mock os.environ as we did before, but we have more options:
#+END_NOTES
** call graph

#+ATTR_HTML: :width 50% :height 50%
#+CAPTION:   The call graph of is_quit()
#+NAME:      fig_ISQUIT
[[./img/call_graph_is_quit.png]]

** mock environ

#+ATTR_HTML: :width 50% :height 50%
#+CAPTION:   The call graph of is_quit() with mocked environ
#+NAME:      fig_ISQUIT_MOCK_ENV
[[./img/call_graph_is_quit_mock_env.png]]

** mock lang()

#+ATTR_HTML: :width 50% :height 50%
#+CAPTION:   The call graph of is_quit() with mocked lang()
#+NAME:      fig_ISQUIT_MOCK_LANG
[[./img/call_graph_is_quit_mock_lang.png]]

** test_is_mock()
#+BEGIN_SRC python
def test_is_quit_english():
    with mock.patch('guessing.i18n.lang', return_value='en'):
        assert i18n.is_quit('QUIT')
        assert i18n.is_quit('  stop ')
        assert i18n.is_quit('exit')
        assert not i18n.is_quit('')
        assert not i18n.is_quit('I want my Mummy!')
        assert not i18n.is_quit('q')
        assert not i18n.is_quit('די')
#+END_SRC
** Meet ~Mock~

#+CREDIT:    https://unsplash.com/photos/BXs8SjVelKs
#+ATTR_HTML: :width 75% :height 5%
#+CAPTION:   I am OK with that
#+NAME:      fig_MOCK
[[./img/happy_dog_with_a_hat.jpg]]

** Lets call this Mock Lulu
Lulu is very accommodating:
#+NAME: code_FIDO
#+BEGIN_SRC python
>>> lulu = mock.Mock(name='Lulu')
>>> lulu
<Mock name='Lulu' id='140518155448504'>
>>> lulu()
<Mock name='Lulu()' id='140518155482336'>
>>> lulu.bark
<Mock name='Lulu.bark' id='140518155483064'>
>>> lulu.bark()
<Mock name='Lulu.bark()' id='140518145633808'>
>>> lulu.bark().run.after(42, what='cats')
<Mock name='Lulu.bark().run.after()' id='140518145716856'>
#+END_SRC
** We can tell Lulu what to do
#+NAME: code_PUPPY
#+BEGIN_SRC python
>>> lulu.bark.return_value = 'Woof!'
>>> lulu.bark()
'Woof!'
>>> lulu.make_puppy.return_value.bark.side_effect = ['yip', 'yeep', 'YEEP']
>>> puppy = Lulu.make_puppy(with_='Fido')
>>> puppy.bark()
'yip'
>>> puppy.bark('again')
'yeep'
>>> puppy.bark(3)
'YEEP'
#+END_SRC

* Thoughts
** patch
   patches the *name* of something
** Mock makes it too easy

- it is too permissive (can be made better)
- if it is unit only, the boundaries between units aren't checked.
- [[https://medium.com/python-pandemonium/mock-or-not-to-mock-41965d33f175][to mock or not to mock]]

* One step on a long journey
  image: https://unsplash.com/photos/1JWmFju8vVg

- no tests
- with unit coverage
- define the boundaries you wish to mock
- define the way you want to construct your mock

* Credits
** links
  - [[https://www.youtube.com/watch?v=zW0f4ZRYF5M][Mocking Strategies]] ([[https://www.slideshare.net/excellaco/mocking-in-python-44973320][slides]]) / Excella's Dan Davis
    at the Django District Meetup group on Feb 10, 2015

  - [[https://www.youtube.com/watch?v=Xu5EhKVZdV8][Stop Moking, Start Testing]] / Augie Fackler, Nathaniel Manista
    Project Hosting at Google Code is a large, well-established system written mostly in Python. We'll share our battle-born convictions about creating tests for test-unfriendly code and the larger topic of testing.
** images
  title: https://unsplash.com/photos/wOHH-NUTvVc
  mock: https://unsplash.com/collections/262992/funny?photo=wOHH-NUTvVc
  happy dog with hat: https://unsplash.com/photos/BXs8SjVelKs
  duck typing: https://unsplash.com/?photo=5x7PmmHanG4
  flimsy: https://unsplash.com/?photo=5DJqsjAYlmk
  coverage: https://unsplash.com/?photo=2Ts5HnA67k8
  danger: https://unsplash.com/search/danger?photo=28v9cq7ytNU
  exception: https://unsplash.com/collections/440851/work?photo=EXuKQaf3Ei8
  brick wall: https://unsplash.com/?photo=daYpIvggFxA
  legacy code: https://unsplash.com/?photo=FX__egbD0zE
  atomic bomb: https://pixabay.com/en/atomic-bomb-mushroom-cloud-explosion-1011738/
  enterprise: https://www.flickr.com/photos/thart2009/22658375526
  sad dog: https://pixabay.com/en/animal-dog-unhappy-sad-art-2274100/
           https://pixabay.com/en/china-dog-sad-animal-wet-1070771/
* didn't make it
** Old examples
**** request time (inspect the world)

 #+BEGIN_SRC python
 from datetime import datetime
 import requests

 def request_time():
     r = requests.get('http://now.httpbin.org/')
     if r.status_code != 200:
        raise RuntimeError("Oy Vey!")
     return datetime.strptime(r.json()['now']['iso8601'],
                              '%Y-%m-%dT%H:%M:%S.%fZ')
 #+END_SRC

**** cmd2 (integration, mock os.system)

 #+BEGIN_SRC python
 >>> c = ExampleCmd()
 >>> c.one_cmd_plus_hooks('shell echo a')
 a
 #+END_SRC

 #+BEGIN_SRC python
 import os

 class ExampleCmd(cmd.Cmd):
     # ...
     def one_cmd_plus_hooks(self, line):
         # ...
         os.system(...)
 #+END_SRC

 #+BEGIN_SRC python
 from unittest.mock import patch

 @patch('os.system')
 def test_exmaple_cmd_shell(mock_system):
     c = ExampleCmd()
     c.one_cmd_plus_hooks('shell echo a')
     mock_system.assert_called_once_with('echo a')
 #+END_SRC

**** get json

 #+BEGIN_SRC python
 def get_json(filename):
     try:
         return json.loads(open(filename).read())
     except (IOError, ValueError):
         return {}
 #+END_SRC

 Well... I can create a `tempfile` with some json in it. And I can put some invalid json to have the ~ValueError~, and there must be something I can do to get an ~IOError~ and I will figure this out later somehow.

 But then you are writing a *functional* test.

**** credit card (side effect)

 #+BEGIN_SRC python
 def charge_credit_card(amount, cc_number, exp_month, exp_year):
     db = Database()
     q = OfflineQueue(db)
     ccp = CreditCardProcessor(q)
     c = CreditCard(cc_number, exp_month, exp_year)
     c.charge(ccp, amount)
 #+END_SRC


** Nerd
:PROPERTIES:
:reveal_background: ./img/at_key_signing_party.jpg
:reveal_background_trans: slide
:END:


This is how to add background image to a silde
